Материал для этого документа был взят из следующих источников:
- http://learn.javascript.ru/
Этот документ предназначен исключительно для личного использования, как краткий конспект по основным моментам языка JavaScript


=== введение ===
Язык CoffeeScript – это «синтаксический сахар» поверх JavaScript. Он сосредоточен на большей ясности и краткости кода. Как правило, его особенно любят программисты на Ruby.
Язык TypeScript сосредоточен на добавлении строгой типизации данных. Он предназначен для упрощения разработки и поддержки больших систем. Его разрабатывает Microsoft.
Язык Dart интересен тем, что он не только транслируется в JavaScript, как и другие языки, но и имеет свою независимую среду выполнения, которая даёт ему ряд возможностей и доступна для встраивания в приложения (вне браузера). Он разрабатывается компанией Google.


=== External Script ===
Атрибут async
Поддерживается всеми браузерами, кроме IE9-. Скрипт выполняется полностью асинхронно. То есть, при обнаружении <script async src="..."> браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет загружен – он выполнится.

Атрибут defer
Поддерживается всеми браузерами, включая самые старые IE. Скрипт также выполняется асинхронно, не заставляет ждать страницу, но есть два отличия от async.
Первое – браузер гарантирует, что относительный порядок скриптов с defer будет сохранён. То есть, в таком коде (с async) первым сработает тот скрипт, который раньше загрузится:
	<script src="1.js" async></script>
	<script src="2.js" async></script>
А в таком коде (с defer) первым сработает всегда 1.js, а скрипт 2.js, даже если загрузился раньше, будет его ждать.
	<script src="1.js" defer></script>
	<script src="2.js" defer></script>
Поэтому атрибут defer используют в тех случаях, когда второй скрипт 2.js зависит от первого 1.js, к примеру – использует что-то, описанное первым скриптом.
Второе отличие – скрипт с defer сработает, когда весь HTML-документ будет обработан браузером. Например, если документ достаточно большой…
	<script src="async.js" async></script>
	<script src="defer.js" defer></script>
	<some code here>
…То скрипт async.js выполнится, как только загрузится – возможно, до того, как весь документ готов. А defer.js подождёт готовности всего документа. Это бывает удобно, когда мы в скрипте хотим работать с документом, и должны быть уверены, что он полностью получен.

async вместе с defer
При одновременном указании async и defer в современных браузерах будет использован только async, в IE9- – только defer (не понимает async).



=== Types ===
В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».

Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined

В явном виде undefined обычно не присваивают, так как это противоречит его смыслу. Для записи в переменную «пустого» или «неизвестного» значения используется null.

1. Результат typeof null == "object" – это официально признанная ошибка в языке, которая сохраняется для совместимости. На самом деле null – это не объект, а отдельный тип данных.
2. Функции мы пройдём чуть позже. Пока лишь заметим, что функции не являются отдельным базовым типом в JavaScript, а подвидом объектов. Но typeof выделяет функции отдельно, возвращая для них "function". На практике это весьма удобно, так как позволяет легко определить функцию.



=== Comparison ===
При сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям:
alert( '2' > 1 ); // true, сравнивается как 2 > 1
alert( '01' == 1 ); // true, сравнивается как 1 == 1
alert( false == 0 ); // true, false становится числом 0
alert( true == 1 ); // true, так как true становится числом 1.

В обычном операторе == есть «проблема» – он не может отличить 0 от false:
  alert( 0 == false ); // true
Та же ситуация с пустой строкой:
  alert( '' == false ); // true
Это естественное следствие того, что операнды разных типов преобразовались к числу. Пустая строка, как и false, при преобразовании к числу дают 0. Что же делать, если всё же нужно отличить 0 от false? Для проверки равенства без преобразования типов используются операторы строгого равенства === (тройное равно) и !==. Если тип разный, то они всегда возвращают false:
  alert( 0 === false ); // false, т.к. типы различны
Строгое сравнение предпочтительно, если мы хотим быть уверены, что «сюрпризов» не будет.

Сравнение с null и undefined
Проблемы со специальными значениями возможны, когда к переменной применяется операция сравнения > < <= >=, а у неё может быть как численное значение, так и null/undefined. Интуитивно кажется, что null/undefined эквивалентны нулю, но это не так. Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка. При преобразовании в число null становится 0, а undefined становится NaN.

Сравним null с нулём:
  alert( null > 0 ); // false
  alert( null == 0 ); // false
Итак, мы получили, что null не больше и не равен нулю. А теперь…
  alert(null >= 0); // true
Как такое возможно? Если нечто «больше или равно нулю», то резонно полагать, что оно либо больше, либо равно. Но здесь это не так. Дело в том, что алгоритмы проверки равенства == и сравнения >= > < <= работают по-разному. Сравнение честно приводит к числу, получается ноль. А при проверке равенства значения null и undefined обрабатываются особым образом: они равны друг другу, но не равны чему-то ещё. В результате получается странная с точки зрения здравого смысла ситуация, которую мы видели в примере выше.

Несравнимый undefined
Значение undefined вообще нельзя сравнивать:
  alert( undefined > 0 ); // false (1)
  alert( undefined < 0 ); // false (2)
  alert( undefined == 0 ); // false (3)
Сравнения (1) и (2) дают false потому, что undefined при преобразовании к числу даёт NaN. А значение NaN по стандарту устроено так, что сравнения ==, <, >, <=, >= и даже === с ним возвращают false. Проверка равенства (3) даёт false, потому что в стандарте явно прописано, что undefined равно лишь null и ничему другому.
Вывод: любые сравнения с undefined/null, кроме точного ===, следует делать с осторожностью. Желательно не использовать сравнения >= > < <= с ними, во избежание ошибок в коде.



=== If/Else ===
Оператор if (...) вычисляет и преобразует выражение в скобках к логическому типу. В логическом контексте:
- Число 0, пустая строка "", null и undefined, а также NaN являются false,
- Остальные значения – true.



=== Logical Ops ===
Итак, как мы видим, оператор ИЛИ вычисляет ровно столько значений, сколько необходимо – до первого true. При этом оператор ИЛИ возвращает то значение, на котором остановились вычисления. Причём, не преобразованное к логическому типу.
Итак, оператор || вычисляет операнды слева направо до первого «истинного» и возвращает его, а если все ложные – то последнее значение. Иначе можно сказать, что "|| запинается на правде".

К И применим тот же принцип «короткого цикла вычислений», но немного по-другому, чем к ИЛИ. Если левый аргумент – false, оператор И возвращает его и заканчивает вычисления. Иначе – вычисляет и возвращает правый аргумент. Итак, оператор && вычисляет операнды слева направо до первого «ложного» и возвращает его, а если все истинные – то последнее значение. Иначе можно сказать, что "&& запинается на лжи".

Действия ! (НЕ):
- Сначала приводит аргумент к логическому типу true/false.
- Затем возвращает противоположное значение.

В частности, двойное НЕ используют для преобразования значений к логическому типу:
  alert( !!"строка" ); // true
  alert( !!null ); // false

Приоритет оператора && выше, чем ||



=== Type Conversion ===
Строковое преобразование
- Строковое преобразование происходит, когда требуется представление чего-либо в виде строки. Например, его производит функция alert.
- Можно также осуществить преобразование явным вызовом String(val)
- Также для явного преобразования применяется оператор "+", у которого один из аргументов строка. В этом случае он приводит к строке и другой аргумент

Численное преобразование
- Сравнение разных типов – значит численное преобразование (кроме сравнений ===, !==)
- Для преобразования к числу в явном виде можно вызвать Number(val)
- поставить перед выражением унарный плюс "+"
Примеры:
undefined -> NaN
null -> 0
true / false -> 1 / 0
Строка -> Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то 0, иначе из непустой строки "считывается" число, при ошибке результат NaN.

Интуитивно, значения null/undefined ассоциируются с нулём, но при преобразованиях ведут себя иначе. Специальные значения преобразуются к числу так:
undefined -> NaN
null -> 0

Это преобразование осуществляется при арифметических операциях и сравнениях > >= < <=, но не при проверке равенства ==. Алгоритм проверки равенства для этих значений в спецификации прописан отдельно (пункт 11.9.3). В нём считается, что null и undefined равны "==" между собой, но эти значения не равны никакому другому значению. Это ведёт к забавным последствиям.
Например, null не подчиняется законам математики – он «больше либо равен нулю»: null>=0, но не больше и не равен:
alert( null >= 0 ); // true, т.к. null преобразуется к 0
alert( null > 0 ); // false (не больше), т.к. null преобразуется к 0
alert( null == 0 ); // false (и не равен!), т.к. == рассматривает null особо.
Значение undefined вообще «несравнимо»:
alert( undefined > 0 ); // false, т.к. undefined -> NaN
alert( undefined == 0 ); // false, т.к. это undefined (без преобразования)
alert( undefined < 0 ); // false, т.к. undefined -> NaN
Для более очевидной работы кода и во избежание ошибок лучше не давать специальным значениям участвовать в сравнениях > >= < <=.

Логическое преобразование
Преобразование к true/false происходит в логическом контексте, таком как if(value), и при применении логических операторов. Все значения, которые интуитивно «пусты», становятся false. Их несколько: 0, пустая строка, null, undefined и NaN. Остальное, в том числе и любые объекты – true.

Для явного преобразования используется двойное логическое отрицание !!value или вызов Boolean(value).

Обратите внимание: строка "0" становится true



=== Function Declaration Expression ===
«Классическое» объявление функции, о котором мы говорили до этого, вида function имя(параметры) {...}, называется в спецификации языка «Function Declaration».
- Function Declaration – функция, объявленная в основном потоке кода. (function sum(a, b))
- Function Expression – объявление функции в контексте какого-либо выражения, например присваивания. (var sum = function(a, b))

Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.
Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.
Если нет явной причины использовать Function Expression – предпочитайте Function Declaration.

Существует ещё один способ создания функции, который используется очень редко, но упомянем и его для полноты картины. Он позволяет создавать функцию полностью «на лету» из строки, вот так:
  var sum = new Function('a,b', ' return a+b; ');
  var result = sum(1, 2);
  alert( result ); // 3
То есть, функция создаётся вызовом new Function(params, code)



=== Recursion ===
У каждого вызова функции есть свой «контекст выполнения» (execution context).
Контекст выполнения – это служебная информация, которая соответствует текущему запуску функции. Она включает в себя локальные переменные функции и конкретное место в коде, на котором находится интерпретатор.
При любом вложенном вызове JavaScript запоминает текущий контекст выполнения в специальной внутренней структуре данных – «стеке контекстов».
Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее. Но переделка рекурсии в цикл может быть нетривиальной, особенно когда в функции, в зависимости от условий, используются различные рекурсивные подвызовы, когда ветвление более сложное.
Применение рекурсии:
- рекурсия используется для работы с «естественно рекурсивными» структурами данных, такими как HTML-документы, для «глубокого» копирования сложных объектов.



=== Named Function Expression ===
Специально для работы с рекурсией в JavaScript существует особое расширение функциональных выражений, которое называется «Named Function Expression» (сокращённо NFE) или, по-русски, «именованное функциональное выражение».
var f = function sayHi(...) { /* тело функции */ };
Имя функционального выражения (sayHi) имеет особый смысл. Оно доступно только изнутри самой функции. Кроме того, имя NFE нельзя перезаписать.
NFE используется в первую очередь в тех ситуациях, когда функцию нужно передавать в другое место кода или перемещать из одной переменной в другую. Внутреннее имя позволяет функции надёжно обращаться к самой себе, где бы она ни находилась.

Вспомним, к примеру, функцию-факториал из задачи Вычислить факториал:
 function f(n) {
  return n ? n * f(n - 1) : 1;
};
alert( f(5) ); // 120

Попробуем перенести её в другую переменную g:
function f(n) {
  return n ? n * f(n - 1) : 1;
};
var g = f;
f = null;
alert( g(5) ); // запуск функции с новым именем - ошибка при выполнении!
Ошибка возникла потому что функция из своего кода обращается к своему старому имени f. А этой функции уже нет, f = null.

Для того, чтобы функция всегда надёжно работала, объявим её как Named Function Expression:
var f = function factorial(n) {
  return n ? n*factorial(n-1) : 1;
};
var g = f;  // скопировали ссылку на функцию-факториал в g
f = null;
alert( g(5) ); // 120, работает!

Обратим внимание, что с Function Declaration так поступить нельзя. Такое «специальное» внутреннее имя функции задаётся только в синтаксисе Function Expression.



=== Properties and Methods ===
Вызов метода - через круглые скобки! Для вызова метода обязательно нужны круглые скобки. Если обратиться к методу без (), то мы получим саму эту функцию.
К методу числа можно обратиться и напрямую:
  alert( 12.34.toFixed(1) ); // 12.3
…Но если число целое, то будет проблема:
  alert(12.toFixed(1)); // ошибка!
Ошибка произойдёт потому, что JavaScript ожидает десятичную дробь после точки. Это – особенность синтаксиса JavaScript. Вот так – будет работать:
  alert( 12..toFixed(1) ); // 12.0



=== ===
var undef; // переменная не присвоена, т.е. равна undefined
Вызов alert не возвращает значения, или, иначе говоря, возвращает undefined.

if (условие) {
  a();
} else {
  b();
}
…Аналогична записи:

условие ? a() : b();

В обоих случаях в зависимости от условия выполняется либо a() либо b(). Но разница состоит в том, что оператор вопросительный знак '?', использованный во второй записи, возвращает значение. Синтаксические конструкции, которые не возвращают значений, нельзя использовать в операторе '?'. К таким относятся большинство конструкций и, в частности, break/continue.

Переменные, объявленные на уровне всего скрипта, называют «глобальными переменными».



=== Modules ===
Модулем считается файл с кодом. В этом файле ключевым словом 'export' помечаются переменные и функции, которые могут быть использованы снаружи. Другие модули могут подключать их через вызов 'import'.
Ключевое слово 'export' можно ставить:
- перед объявлением переменных, функций и классов.
- отдельно, при этом в фигурных скобках указывается, что именно экспортируется.

Другие модули могут подключать экспортированные значения при помощи ключевого слова import:
  import {one, two} from "./nums";



=== Functions Basics ===
Локальные переменные объявленные внутри функции видны только внутри функции.
Блоки if/else, switch, for, while, do..while не влияют на область видимости переменных.
Неважно, где именно в функции и сколько раз объявляется переменная. Любое объявление срабатывает один раз и распространяется на всю функцию.

Параметры функции копируются в локальные переменные функции.

- Функцию можно вызвать с любым количеством аргументов. Если параметр не передан при вызове – он считается равным undefined.
- При объявлении функции необязательные аргументы, как правило, располагают в конце списка.
- В случае, когда функция не вернула значение или return был без аргументов, считается что она вернула undefined



=== Number ===
В JavaScript можно записывать числа не только в десятичной, но и в шестнадцатеричной (начинается с 0x) системе счисления:
  alert( 0xFF ); // 255 в шестнадцатиричной системе
  // еще пример научной формы: 3 с 5 нулями
  alert( 3e5 ); // 300000
  // здесь 3 сдвинуто 5 раз вправо, за десятичную точку.
  alert( 3e-5 ); // 0.00003  <-- 5 нулей, включая начальный ноль

Infinity – особенное численное значение, которое ведет себя в точности как математическая бесконечность ∞.
- Infinity больше любого числа.
- Добавление к бесконечности не меняет её.
  alert( Infinity > 1234567890 ); // true
  alert( Infinity + 5 == Infinity ); // true
Бесконечность можно присвоить и в явном виде: var x = Infinity.

Если математическая операция не может быть совершена, то возвращается специальное значение NaN (Not-A-Number).
Например, деление 0/0 в математическом смысле неопределено, поэтому его результат NaN:
  alert( 0 / 0 ); // NaN
- Значение NaN – единственное, в своем роде, которое не равно ничему, включая себя.
  if (NaN == NaN) alert( "==" ); // Ни один вызов
  if (NaN === NaN) alert( "===" ); // не сработает
- Значение NaN можно проверить специальной функцией isNaN(n), которая преобразует аргумент к числу и возвращает true, если получилось NaN, и false – для любого другого значения.
  var n = 0 / 0;
  alert( isNaN(n) ); // true
  alert( isNaN("12") ); // false, строка преобразовалась к обычному числу 12
- Значение NaN «прилипчиво». Любая операция с NaN возвращает NaN.
  alert( NaN + 1 ); // NaN

Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity:
  alert( isFinite(1) ); // true
  alert( isFinite(Infinity) ); // false
  alert( isFinite(NaN) ); // false

Большинство арифметических операций и математических функций преобразуют значение в число автоматически. Для того, чтобы сделать это явно, обычно перед значением ставят унарный плюс '+'. При этом, если строка не является в точности числом, то результат будет NaN:
  alert( +"12test" ); // NaN 
Единственное исключение – пробельные символы в начале и в конце строки, которые игнорируются:
  alert( +"  -12" ); // -12
  alert( +" \n34  \n" ); // 34, перевод строки \n является пробельным символом
  alert( +"" ); // 0, пустая строка становится нулем
  alert( +"1 2" ); // NaN, пробел посередине числа - ошибка

Аналогичным образом происходит преобразование и в других математических операторах и функциях:
  alert( '12.34' / "-2" ); // -6.17

Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.
  alert( parseInt('12px') ) // 12, ошибка на символе 'p'
  alert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке

Конечно, существуют ситуации, когда parseInt/parseFloat возвращают NaN. Это происходит при ошибке на первом же символе:
  alert( parseInt('a123') ); // NaN
Функция parseInt также позволяет указать систему счисления, то есть считывать числа, заданные в шестнадцатиричной и других системах счисления:
  alert( parseInt('FF', 16) ); // 255

Для проверки строки на число можно использовать функцию isNaN(str). Однако, у такой проверки есть две особенности:
1. Пустая строка и строка из пробельных символов преобразуются к 0, поэтому считаются числами.
2. Если применить такую проверку не к строке, то могут быть сюрпризы, в частности isNaN посчитает числами значения false, true, null, так как они хотя и не числа, но преобразуются к ним.
Если же нужна действительно точная проверка на число, которая не считает числом строку из пробелов, логические и специальные значения, а также отсекает Infinity – используйте следующую функцию isNumeric:
  function isNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }
Одна из самых частых операций с числом – округление. В JavaScript существуют целых 3 функции для этого.
- Math.floor (Округляет вниз)
- Math.ceil (Округляет вверх)
- Math.round (Округляет до ближайшего целого)

Округление битовыми операторами
Битовые операторы делают любое число 32-битным целым, обрезая десятичную часть. В результате побитовая операция, которая не изменяет число, например, двойное битовое НЕ – округляет его:
  alert( ~~12.3 ); // 12
Любая побитовая операция такого рода подойдет, например XOR (исключающее ИЛИ, "^") с нулем:
  alert( 12.3 ^ 0 ); // 12
  alert( 1.2 + 1.3 ^ 0 ); // 2, приоритет ^ меньше, чем +
Это удобно в первую очередь тем, что легко читается и не заставляет ставить дополнительные скобки как Math.floor(...):
  var x = a * b / c ^ 0; // читается как "a * b / c и округлить"


Округление до заданной точности

Для округления до нужной цифры после запятой можно умножить и поделить на 10 с нужным количеством нулей. Например, округлим 3.456 до 2-го знака после запятой:
  var n = 3.456;
  alert( Math.round(n * 100) / 100 ); // 3.456 -> 345.6 -> 346 -> 3.46
Существует также специальный метод num.toFixed(precision), который округляет число num до точности precision и возвращает результат в виде строки:
  var n = 12.34;
  alert( n.toFixed(1) ); // "12.3"
Округление идёт до ближайшего значения, аналогично Math.round.



=== String ===
Внутренним форматом строк, вне зависимости от кодировки страницы, является Юникод (Unicode).

Если строка в одинарных кавычках, то внутренние одинарные кавычки внутри должны быть экранированы, то есть снабжены обратным слешем \', вот так:
  var str = 'I\'m a JavaScript programmer';
Сам символ обратного слэша '\' является служебным, поэтому всегда экранируется, т.е пишется как \\
Заэкранировать можно любой символ. Если он не специальный, то ничего не произойдёт

В JavaScript нет отдельного типа «символ», так что charAt возвращает строку, состоящую из выбранного символа.

Разница между str[0] и str.charAt(0) заключается в том, что если символа нет – charAt выдает пустую строку, а скобки – undefined. Вообще же метод charAt существует по историческим причинам, ведь квадратные скобки – проще и короче.

Просто запомните: '~' читается как «не минус один», а "if ~str.indexOf" читается как "если найдено".

substring(start [, end]) - Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end. Если аргумент end отсутствует, то идет до конца строки.
substr(start [, length]) - Первый аргумент имеет такой ж смысл, как и в substring, а второй содержит не конечную позицию, а количество символов. Если второго аргумента нет – подразумевается «до конца строки».
slice(start [, end]) - Возвращает часть строки от позиции start до, но не включая, позиции end. Смысл параметров – такой же как в substring.

Отличия substring от slice:
- substring(start, end)
Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки
Кроме того, если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end
- slice
Отрицательные значения отсчитываются от конца строки
  alert( "testme".slice(-2) ); // "me", от 2 позиции с конца
  alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.

String.fromCharCode(code) - Возвращает символ по коду code
str.charCodeAt(pos) - Возвращает код символа на позиции pos. Отсчет позиции начинается с нуля

Метод str1.localeCompare(str2) возвращает -1, если str1 < str2, 1, если str1 > str2 и 0, если они равны.



=== Object ===
Объекты в JavaScript сочетают в себе два важных функционала:
- Первый – это ассоциативный массив: структура, пригодная для хранения любых данных. В этой главе мы рассмотрим использование объектов именно как массивов.
- Второй – языковые возможности для объектно-ориентированного программирования. Эти возможности мы изучим в последующих разделах учебника.

Ассоциативный массив – структура данных, в которой можно хранить любые данные в формате ключ-значение.

Пустой объект может быть создан одним из двух синтаксисов:
1. o = new Object();
2. o = {}; // пустые фигурные скобки

Основные операции с объектами – это создание, получение и удаление свойств.
Дело в том, что в JavaScript можно обратиться к любому свойству объекта, даже если его нет.
Существует альтернативный синтаксис работы со свойствами, использующий квадратные скобки объект['свойство']. Иимя свойства обязано быть строкой. Если использовано значение другого типа – JavaScript приведет его к строке автоматически. Квадратные скобки также позволяют обратиться к свойству, имя которого хранится в переменной. Доступ через точку используется, если мы на этапе написания программы уже знаем название свойства. А если оно будет определено по ходу выполнения, например, введено посетителем и записано в переменную, то единственный выбор – квадратные скобки.


Для перебора всех свойств из объекта используется цикл по свойствам for..in.
  for (var key in menu) {
    // этот код будет вызван для каждого свойства объекта и выведет имя свойства и его значение
    alert( "Ключ: " + key + " значение: " + menu[key] );
  }
Обратите внимание, мы использовали квадратные скобки menu[key]. Как уже говорилось, если имя свойства хранится в переменной, то обратиться к нему можно только так, не через точку.

Правда ли, что при переборе for(key in codes) ключи key будут перечислены именно в том порядке, в котором заданы? По стандарту – нет. Но некоторое соглашение об этом, всё же, есть. Соглашение говорит, что если имя свойства – нечисловая строка, то такие ключи всегда перебираются в том же порядке, в каком присваивались. С другой стороны, если имя свойства – число или числовая строка, то все современные браузеры сортируют такие свойства в целях внутренней оптимизации.
А что, если мы хотим, чтобы порядок был именно таким, какой мы задали? Это возможно. Можно применить небольшой хак, который заключается в том, чтобы сделать все ключи нечисловыми, например, добавим в начало дополнительный символ '+':
  var codes = {
    "+7": "Россия",
    "+38": "Украина",
    "+1": "США"
  };

  for (var code in codes) {
    var value = codes[code];
    code = +code; // ..если нам нужно именно число, преобразуем: "+7" -> 7

    alert( code + ": " + value ); // 7, 38, 1 во всех браузерах
  }


Фундаментальным отличием объектов от примитивов, является их хранение и копирование «по ссылке».
В переменной, которой присвоен объект, хранится не сам объект, а «адрес его места в памяти», иными словами – «ссылка» на него.
При копировании переменной с объектом – копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре.
Так как объект всего один, то изменения через любую переменную видны в других переменных.

Иногда, на практике – очень редко, нужно скопировать объект целиком, создать именно полную независимую копию, «клон» объекта. Что ж, можно сделать и это. Для этого нужно пройти по объекту, достать данные и скопировать на уровне примитивов. Если же свойства объектов, в свою очередь, могут хранить ссылки на другие объекты, то нужно обойти такие подобъекты и тоже склонировать их. Это называют «глубоким» клонированием.

При «раскрытии» свойств объекта в консоли – браузер всегда выводит их текущие (на момент раскрытия) значения.

- Объект присваивается и копируется «по ссылке». То есть, в переменной хранится не сам объект а, условно говоря, адрес в памяти, где он находится.
- Если переменная-объект скопирована или передана в функцию, то копируется именно эта ссылка, а объект остаётся один в памяти.
Это – одно из ключевых отличий объекта от примитива (числа, строки…), который при присвоении как раз копируется «по значению», то есть полностью.



=== Arrays ===
Массив – разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для удобного манипулирования такой коллекцией. Они обычно используются для хранения упорядоченных коллекций данных, например – списка товаров на странице, студентов в группе и т.п.
  var arr = [];
В массиве может храниться любое число элементов любого типа.

Одно из применений массива – это очередь. В классическом программировании так называют упорядоченную коллекцию элементов, такую что элементы добавляются в конец, а обрабатываются – с начала. В реальной жизни эта структура данных встречается очень часто. Например, очередь сообщений, которые надо показать на экране. Очень близка к очереди еще одна структура данных: стек. Это такая коллекция элементов, в которой новые элементы добавляются в конец и берутся с конца.
pop - Удаляет последний элемент из массива и возвращает его
push - Добавляет элемент в конец массива
shift - Удаляет из массива первый элемент и возвращает его
unshift - Добавляет элемент в начало массива
Методы push и unshift могут добавлять сразу по несколько элементов

Массив – это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length. Так как это объект, то в функцию он передаётся по ссылке.

Как правило, нет причин использовать массив как обычный объект, хотя технически это и возможно.

Если в массиве есть пропущенные индексы, то при выводе в большинстве браузеров появляются «лишние» запятые

Не используйте for..in для массивов:
1. Цикл for..in выведет все свойства объекта, а не только цифровые.
2. Цикл for (var i=0; i<arr.length; i++) в современных браузерах выполняется в 10-100 раз быстрее. Казалось бы, по виду он сложнее, но браузер особым образом оптимизирует такие циклы.

Длина length – не количество элементов массива, а последний индекс + 1.
При уменьшении length массив укорачивается.
Самый простой способ очистить массив – это arr.length=0.

Существует еще один синтаксис для создания массива:
  var arr = new Array("Яблоко", "Груша", "и т.п.");
Кроме того, у него есть одна особенность. Обычно new Array(элементы, ...) создаёт массив из данных элементов, но если у него один аргумент-число new Array(число), то он создает массив без элементов, но с заданной длиной.
Массивы в JavaScript могут содержать в качестве элементов другие массивы. Это можно использовать для создания многомерных массивов, например матриц

Современные интерпретаторы стараются оптимизировать их и хранить в памяти не в виде хэш-таблицы, а в виде непрерывной области памяти, по которой легко пробежаться от начала до конца.

split(s) - озволяет превратить строку в массив, разбив ее по разделителю s. У метода split есть необязательный второй аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано – остаток массива будет отброшен. Вызов split с пустой строкой разобьёт по буквам.

join(str) - делает в точности противоположное split. Он берет массив и склеивает его в строку, используя str как разделитель.

Удаления из массива:
  delete arr[1]; // значение с индексом 1 удалено
  // теперь arr = ["Я", undefined, "домой"];
  alert( arr[1] ); // undefined

splice – это универсальный раскладной нож для работы с массивами. Умеет все: удалять элементы, вставлять элементы, заменять элементы – по очереди и одновременно.
  arr.splice(index[, deleteCount, elem1, ..., elemN])
Пример:
  var arr = ["Я", "сейчас", "изучаю", "JavaScript"];
  // удалить 3 первых элемента и добавить другие вместо них
  arr.splice(0, 3, "Мы", "изучаем")
  alert( arr ) // теперь ["Мы", "изучаем", "JavaScript"] 
splice возвращает массив из удаленных элементов

Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:
  var arr = ["Я", "изучаю", "JavaScript"];
  // с позиции 2 удалить 0 вставить "сложный", "язык"
  arr.splice(2, 0, "сложный", "язык");
  alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"

Допускается использование отрицательного номера позиции, которая в этом случае отсчитывается с конца:
  var arr = [1, 2, 5]
  // начиная с позиции индексом -1 (перед последним элементом) удалить 0 элементов, затем вставить числа 3 и 4
  arr.splice(-1, 0, 3, 4);
  alert( arr ); // результат: 1,2,3,4,5

slice(begin, end) копирует участок массива от begin до end, не включая end. Исходный массив при этом не меняется.
Аргументы ведут себя так же, как и в строковом slice:
- Если не указать end – копирование будет до конца массива
- Можно использовать отрицательные индексы, они отсчитываются с конца
- Если вообще не указать аргументов – скопируется весь массив:

sort() сортирует массив на месте. По умолчанию sort сортирует, преобразуя элементы к строке. Для указания своего порядка сортировки в метод arr.sort(fn) нужно передать функцию fn от двух элементов, которая умеет сравнивать их.
Например, укажем эту функцию явно, отсортируем элементы массива как числа:
  function compareNumeric(a, b) {
    if (a > b) return 1;
    if (a < b) return -1;
  }
  var arr = [ 1, 2, 15 ];
  arr.sort(compareNumeric);
  alert(arr);  // 1, 2, 15

Функцию compareNumeric для сравнения элементов-чисел можно упростить до одной строчки.
  function compareNumeric(a, b) {
    return a - b;
  }
Эта функция вполне подходит для sort, так как возвращает положительное число, если a > b, отрицательное, если наоборот, и 0, если числа равны.

Метод arr.reverse() меняет порядок элементов в массиве на обратный.
Метод arr.concat(value1, value2, … valueN) создаёт новый массив, в который копируются элементы из arr, а также value1, value2, ... valueN.
У concat есть одна забавная особенность. Если аргумент concat – массив, то concat добавляет элементы из него.

Метод «arr.indexOf(searchElement[, fromIndex])» возвращает номер элемента searchElement в массиве arr или -1, если его нет. Поиск начинается с номера fromIndex, если он указан. Если нет – с начала массива. Для поиска используется строгое сравнение ===.
Метод «arr.lastIndexOf(searchElement[, fromIndex])» ищет справа-налево: с конца массива или с номера fromIndex, если он указан.
Методы indexOf/lastIndexOf осуществляют поиск перебором

Ранее мы говорили о том, что свойства объекта можно перебрать в цикле for..in. Если мы хотим работать с ними в виде массива, то к нашим услугам – замечательный метод Object.keys(obj).
  var user = {
    name: "Петя",
    age: 30
  }
  var keys = Object.keys(user);
  alert( keys ); // name, age

Метод «arr.forEach(callback[, thisArg])» используется для перебора массива. Он для каждого элемента массива вызывает функцию callback. Этой функции он передаёт три параметра callback(item, i, arr):
  item – очередной элемент массива.
  i – его номер.
  arr – массив, который перебирается.
Метод forEach ничего не возвращает, его используют только для перебора, как более «элегантный» вариант, чем обычный цикл for.

Метод «arr.filter(callback[, thisArg])» используется для фильтрации массива через функцию. Он создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true.

Метод «arr.map(callback[, thisArg])» используется для трансформации массива. Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr.

Метод «arr.every(callback[, thisArg])» возвращает true, если вызов callback вернёт true для каждого элемента arr.
Метод «arr.some(callback[, thisArg])» возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr.

Метод «arr.reduce(callback[, initialValue])» используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.
Аргументы функции callback(previousValue, currentItem, index, arr):
- previousValue – последний результат вызова функции, он же «промежуточный результат».
- currentItem – текущий элемент массива, элементы перебираются по очереди слева-направо.
- index – номер текущего элемента.
- arr – обрабатываемый массив.

var arr = [1, 2, 3, 4, 5]
// для каждого элемента массива запустить функцию, промежуточный результат передавать первым аргументом далее
  var result = arr.reduce(function(sum, current) {
    return sum + current;
  }, 0);
  alert( result ); // 15
Метод arr.reduceRight работает аналогично, но идёт по массиву справа-налево.



=== Pseudoarray ===
copy(dst, src1, src2…) - Копирует свойства из объектов src1, src2,... в объект dst. Возвращает получившийся объект.
Использование:
- Для объединения нескольких объектов в один
- Для создания копии объекта user



=== ИТОГО === 
- Скрипты вставляются на страницу как текст в теге <script>, либо как внешний файл через <script src="путь"></script>
- Специальные атрибуты async и defer используются для того, чтобы пока грузится внешний скрипт – браузер показал остальную (следующую за ним) часть страницы. Без них этого не происходит.
- Разница между async и defer: атрибут defer сохраняет относительную последовательность скриптов, а async – нет. Кроме того, defer всегда ждёт, пока весь HTML-документ будет готов, а async – нет.  

http://learn.javascript.ru/javascript-specials
- Значение null не является «ссылкой на нулевой адрес/объект» или чем-то подобным. Это просто специальное значение.
- Значение undefined означает «переменная не присвоена».
- Для сложения строк используется оператор +. (Если хоть один аргумент – строка, то другой тоже приводится к строке)
- Сравнение === проверяет точное равенство, включая одинаковый тип. Это самый очевидный и надёжный способ сравнения.]
- Остальные сравнения == < <= > >= осуществляют числовое приведение типа
- Также: значения null и undefined при == равны друг другу и не равны ничему ещё. А при операторах больше/меньше происходит приведение null к 0, а undefined к NaN.
- Сравнение строк – лексикографическое, символы сравниваются по своим unicode-кодам. (Поэтому получается, что строчные буквы всегда больше, чем прописные)
- Результатом логического оператора служит последнее значение в коротком цикле вычислений.